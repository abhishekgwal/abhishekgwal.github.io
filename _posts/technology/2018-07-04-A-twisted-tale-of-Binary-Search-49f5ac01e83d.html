---
layout: post
title: "A twisted tale of Binary Search"
comments : True
---

<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>A twisted tale of Binary Search</title><style>
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 100%;
        margin: auto;
      }
      section {
        width: 100%;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 100%;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">A twisted tale of Binary Search</h1>
</header>
<section data-field="subtitle" class="p-summary">
Awesome. That‚Äôs how I feel right now. Writing my first solo tech article.
</section>
<section data-field="body" class="e-content">
<section name="75b2" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="48e2" id="48e2" class="graf graf--h3 graf--leading graf--title"></h3></div><div class="section-inner sectionLayout--fullWidth"><figure name="cd3f" id="cd3f" class="graf graf--figure graf--layoutFillWidth graf-after--h3"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 100%;"></div><img class="graf-image" data-image-id="1*DClFFS2kX-MPvGuHYvOyTw.jpeg" data-width="1500" data-height="1500" src="https://cdn-images-1.medium.com/max/2000/1*DClFFS2kX-MPvGuHYvOyTw.jpeg"></div><figcaption class="imageCaption">Source: <a href="https://www.pinterest.com/pin/261912534550561245/?lp=true" data-href="https://www.pinterest.com/pin/261912534550561245/?lp=true" class="markup--anchor markup--figure-anchor" rel="nofollow noopener noopener" target="_blank">https://www.pinterest.com/pin/261912534550561245/?lp=true</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="a2dc" id="a2dc" class="graf graf--p graf-after--figure">Awesome. That‚Äôs how I feel right now. Writing my first solo tech article.</p><p name="b2ec" id="b2ec" class="graf graf--p graf-after--p">I must say I have a lot to share with you guys, and have a lot more to learn as well. So without any further ado, lets get to it. And yes, hold on tight‚Ää‚Äî‚Ää‚Äòcause there is a twist in the tale. üòú</p><h3 name="9317" id="9317" class="graf graf--h3 graf-after--p">Binary Search</h3><p name="a378" id="a378" class="graf graf--p graf-after--h3">All of us have heard of the classic <a href="https://www.geeksforgeeks.org/puzzle-set-35-2-eggs-and-100-floors/" data-href="https://www.geeksforgeeks.org/puzzle-set-35-2-eggs-and-100-floors/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">2 Eggs and 100 Stories</a> problem. I have something similar for you.</p><p name="2968" id="2968" class="graf graf--p graf-after--p">You have a 100 story building with a rule:</p><p name="3ab9" id="3ab9" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">People with pets can only occupy top floors</strong></code></p><p name="28b9" id="28b9" class="graf graf--p graf-after--p">Your friend wishes to buy an apartment in this building. She is too scared of pets to live near them, but you love them. She asked if you can help her find out where exactly the pet friendly floors start. She wants to explore all of the different options available, and so you need to find out which floors starting from the ground up are the ones that don‚Äôt allow pets.</p><p name="d6f4" id="d6f4" class="graf graf--p graf-after--p">The building management folks are on a holiday. On every floor, there is a sign board next to the elevator telling you if the floor is pet friendly or not. But you are too lazy to stop at every floor to check the pet sign board since the lift is so slow.</p><p name="0e70" id="0e70" class="graf graf--p graf-after--p">What do you do?</p><figure name="de53" id="de53" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 322px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 46%;"></div><img class="graf-image" data-image-id="1*mVvYhywAIoa11tCRfsHPQA.png" data-width="1492" data-height="686" src="https://cdn-images-1.medium.com/max/800/1*mVvYhywAIoa11tCRfsHPQA.png"></div><figcaption class="imageCaption">The two possible sign boards. #GoRed is what your friend roots¬†for.</figcaption></figure><p name="4a8b" id="4a8b" class="graf graf--p graf-after--figure">The lift takes almost a minute at every floor to stop and then start again. Yes that‚Äôs how bad it is. But between the floors, navigation is pretty smooth. You have to get this done quickly.</p><p name="d93e" id="d93e" class="graf graf--p graf-after--p">How do you go about it¬†?</p><h3 name="6429" id="6429" class="graf graf--h3 graf-after--p">Iterative approach</h3><p name="be82" id="be82" class="graf graf--p graf-after--h3">One na√Øve approach to this would be to start at the very bottom of the building (the ground floor) and keep stopping the lift at every single floor to check the sign that floor has posted. You stop when you find the pet friendly sign.</p><p name="88c9" id="88c9" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Best case </strong>is that the ground floor has the pet sign. Meaning the entire building has pets. No way your friend would buy an apartment here.</p><p name="ac27" id="ac27" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Average case </strong>is that you go to the 50th floor, stopping at every floor in between, and finally find a pet sign board. So your friend can buy one from 1‚Äì49.</p><p name="2ff8" id="2ff8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Worst case </strong>scenario would be you reaching the 100th floor, stopping at every floor on the way up, only to find out that there are no pet sign boards in the entire building. So your friend can buy any apartment from 1‚Äì100, but who cares, it took you almost two hours to find that out. üòê üòê.</p><p name="3f39" id="3f39" class="graf graf--p graf-after--p">Algorithmically, given an array of 100 boolean values, the index of the array represents building floors and a 0 represents a floor where no pets are allowed while a 1 represents a floor where pets would be allowed. From the rule of the building, the array would be of the form</p><pre name="239c" id="239c" class="graf graf--pre graf-after--p">000... 1111...</pre><p name="3ce0" id="3ce0" class="graf graf--p graf-after--pre">that is, all 0s followed by all 1s, because only the top floors can be the ones where pets are allowed.</p><p name="5234" id="5234" class="graf graf--p graf-after--p">Given this array, we need to find the first index where there is a <code class="markup--code markup--p-code">1</code>¬†. A linear search algorithm for this problem would be as simple as iterating over the array and looking for a <code class="markup--code markup--p-code">1</code> and returning when we find one.</p><figure name="71ad" id="71ad" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/490edc70c77ef2f9f84abb811fdfae5e.js"></script></figure><p name="fcde" id="fcde" class="graf graf--p graf-after--figure">As expected, the complexity of this algorithm would be <code class="markup--code markup--p-code">O(n)</code> where n = 100 for our specific building example. You need to come up with something faster than this. Stopping at every floor is not feasible, as it would take you a lot of time to cover the entire building in the worst case.</p><h3 name="1791" id="1791" class="graf graf--h3 graf-after--p">Binary Search¬†Approach</h3><p name="d212" id="d212" class="graf graf--p graf-after--h3">Let‚Äôs say you start from ground floor and got to the 50th floor with no stops. At the 50th floor, you stopped and got out of the lift and checked for the sign. The board sign said <code class="markup--code markup--p-code">‚ÄúNo Pets‚Äù</code>. This would mean that, until the 50th floor, there are definitely no pets.</p><p name="673f" id="673f" class="graf graf--p graf-after--p">So now knowing that you reduce your search space to the other half, which is floors 51‚Äì100. This means that with a single stop, you were able to cover half of the building knowing for sure that the first half doesn‚Äôt have any pets. That‚Äôs amazing!</p><p name="cbec" id="cbec" class="graf graf--p graf-after--p">Moving on, you again divide your remaining set of floors into half and take the lift and go directly to the 75th floor. And you see a <code class="markup--code markup--p-code">‚ÄúPets‚Äù</code> sign board there. This means the floor where it started showing up must be between 50‚Äì75. You can keep following a similar approach of diving the remaining floors into half and checking until you find the first floor with the <code class="markup--code markup--p-code">‚ÄúPets‚Äù</code> sign board.</p><p name="c06b" id="c06b" class="graf graf--p graf-after--p">You see, every time you make a decision, you divide your search space into two halves and go ahead with one half of the search space. That‚Äôs how we narrow down our search. Since we always divide the search space in two and choose one over the other, that is why this type of search strategy is called a <code class="markup--code markup--p-code">Binary</code> search strategy.</p><p name="39c6" id="39c6" class="graf graf--p graf-after--p">Isn‚Äôt that way faster?</p><p name="f419" id="f419" class="graf graf--p graf-after--p">Let‚Äôs look into the algorithm for this.</p><figure name="2347" id="2347" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 397px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.699999999999996%;"></div><img class="graf-image" data-image-id="1*5xqxb4gs88vQGaK8CCp47w.png" data-width="1472" data-height="834" src="https://cdn-images-1.medium.com/max/800/1*5xqxb4gs88vQGaK8CCp47w.png"></div><figcaption class="imageCaption">Binary Search Algorithm</figcaption></figure><p name="9b3f" id="9b3f" class="graf graf--p graf-after--figure">If you‚Äôve been following along closely and have a grasp of the algorithm, you would have realized a hard and fast condition for the binary search algorithm to work. The condition is that the array needs to be sorted beforehand. In our example, the building floors were sorted from 1‚Äì100 and we could easily divide the search space in two.</p><p name="ac11" id="ac11" class="graf graf--p graf-after--p">Let‚Äôs look at an example array which is sorted and try and search for an element in it.</p><figure name="98d5" id="98d5" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 509px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 72.8%;"></div><img class="graf-image" data-image-id="1*sCdkKU8RqA6_R3uiy4nL2w.png" data-width="1182" data-height="860" src="https://cdn-images-1.medium.com/max/800/1*sCdkKU8RqA6_R3uiy4nL2w.png"></div></figure><p name="8bb1" id="8bb1" class="graf graf--p graf-after--figure">In the above example, the element to be searched is 8. The given array is a sorted array in increasing order. Once we find the middle element (which is 5), we see that the element to be searched is greater than the current index element. Since the array is sorted in increasing order, 8 would lie on the right of the array and can never be on the left side.</p><p name="bb9f" id="bb9f" class="graf graf--p graf-after--p">So we ignore the elements to the left of 5 and continue our search with the remaining elements, eventually finding out 8.</p><figure name="947c" id="947c" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 592px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 84.5%;"></div><img class="graf-image" data-image-id="1*S2lDovD5HeUsdSHm3NM4Sw.png" data-width="1396" data-height="1180" src="https://cdn-images-1.medium.com/max/800/1*S2lDovD5HeUsdSHm3NM4Sw.png"></div></figure><p name="5b25" id="5b25" class="graf graf--p graf-after--figure">On the other hand, what if the array is not sorted? Even though we know the current element is 5 and we know we need to search for 8, we are not sure which direction is the right way to go. If we end up thinking the array is sorted and apply binary search and go to the right part, we will never find 8.</p><p name="7c01" id="7c01" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">So binary search essentially wants your array to be sorted.</strong></p><p name="1669" id="1669" class="graf graf--p graf-after--p">That was the standard binary search algorithm that we just looked at. But, as the title of the article suggests, there is a twist in the tale!</p><figure name="fd19" id="fd19" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://giphy.com/embed/3o7TKAdOad9Y3eSMZG/twitter/iframe" width="100%" height="290" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption">Source: <a href="https://giphy.com/gifs/studiosoriginals-parker-jackson-mushy-3o7TKAdOad9Y3eSMZG" data-href="https://giphy.com/gifs/studiosoriginals-parker-jackson-mushy-3o7TKAdOad9Y3eSMZG" class="markup--anchor markup--figure-anchor" rel="nofollow noopener noopener" target="_blank">https://giphy.com/gifs/studiosoriginals-parker-jackson-mushy-3o7TKAdOad9Y3eSMZG</a></figcaption></figure><p name="64fe" id="64fe" class="graf graf--p graf-after--figure">I am an avid competitive programmer, and there was an interesting variant of the binary search algorithm in the <a href="https://www.codechef.com/MAY18B/problems/FAKEBS" data-href="https://www.codechef.com/MAY18B/problems/FAKEBS" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">CodeChef May Long Challenge</a>.</p><p name="b4a1" id="b4a1" class="graf graf--p graf-after--p">Essentially, the Chef wrote the classic binary search, assuming the input array would be sorted. All the other children in the class copied the code from him, as Chef is the best programmer in the class. His assumption could‚Äôve cost the entire class their assignment marks, as the input array was not sorted beforehand.</p><p name="86bb" id="86bb" class="graf graf--p graf-after--p">The only thing the Chef can do is to preprocess the array by swapping some pair of numbers here and there so that the binary search procedure still returns the right index.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="adf9" id="adf9" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 443px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 44.3%;"></div><img class="graf-image" data-image-id="1*MOupjMd8PLQIkCoXHPIkHw.png" data-width="1882" data-height="834" src="https://cdn-images-1.medium.com/max/1000/1*MOupjMd8PLQIkCoXHPIkHw.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="3c11" id="3c11" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Note: </strong>The preprocessor above should ideally return the modified array for the binary search to work correctly. However, as the problem statement asks, we are just trying to determine the number of swaps needed for binary search to work correctly on the unsorted array given an input. The algorithm would also return a -1 if such a modification is not possible for the given array and element.</p><p name="780d" id="780d" class="graf graf--p graf-after--p">The idea here is very simple.</p><p name="81bd" id="81bd" class="graf graf--p graf-after--p">We need to understand two basic steps. I call them the <strong class="markup--strong markup--p-strong">TI-ME</strong> steps. Perhaps that‚Äôll help you remember what we are doing here.</p><p name="981f" id="981f" class="graf graf--p graf-after--p">a. <strong class="markup--strong markup--p-strong">T</strong>arget <strong class="markup--strong markup--p-strong">I</strong>ndex: The index of the element to be searched for. We need to know this, since this index would help us drive the modifications. Because every time we modify any element, we need to sail towards this index and not away from it.</p><p name="6663" id="6663" class="graf graf--p graf-after--p">b. <strong class="markup--strong markup--p-strong">M</strong>iddle<strong class="markup--strong markup--p-strong"> E</strong>lement: If you look clearly in a binary search, it‚Äôs the middle element of the current search space which drives the next move. If this middle element takes us in the wrong direction, we need to replace with the appropriate element.</p><figure name="b392" id="b392" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 244px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 34.9%;"></div><img class="graf-image" data-image-id="1*xgnYQLeH-9l2MVU_OqTNLQ.png" data-width="1526" data-height="532" src="https://cdn-images-1.medium.com/max/800/1*xgnYQLeH-9l2MVU_OqTNLQ.png"></div><figcaption class="imageCaption">We are searching for 8 in the above unsorted array. We already saw in the examples above a normal binary search would fail for an unsorted¬†array.</figcaption></figure><figure name="2102" id="2102" class="graf graf--figure graf-after--figure"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 334px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 47.699999999999996%;"></div><img class="graf-image" data-image-id="1*sJNU_8PdNlbIuy7RStVHdA.png" data-width="1488" data-height="710" src="https://cdn-images-1.medium.com/max/800/1*sJNU_8PdNlbIuy7RStVHdA.png"></div><figcaption class="imageCaption">Mid elements give direction to binary search. Middle element 5 would take binary search to go right. This way we would never find <code class="markup--code markup--figure-code">8. If we swap 5 with an element greater than 8 we would force the search to go to¬†left.</code></figcaption></figure><p name="0582" id="0582" class="graf graf--p graf-after--figure">So, the whole idea here is that we swap all the middle elements which are wrongly placed.</p><p name="ed72" id="ed72" class="graf graf--p graf-after--p">The binary search algorithm (the value of the middle element with respect to the element to be searched, that is, X) can either take us towards the left half of the array or the right half. So, there are two possibilities for a wrongly placed middle element:</p><ol class="postList"><li name="9b79" id="9b79" class="graf graf--li graf-after--p">The element to be searched was on the right of the middle element, but since <code class="markup--code markup--li-code">Element[Mid] &gt; Element[Target Index]</code>¬†, the binary search would have had to ignore the right half and move towards the left half. OR</li><li name="175e" id="175e" class="graf graf--li graf-after--li">The element to be searched was on the left of the middle element, but since <code class="markup--code markup--li-code">Element[Mid] &lt; Element[Target Index]</code>¬†, the binary search would have had to ignore the left half and move towards the right half.</li></ol><p name="a46d" id="a46d" class="graf graf--p graf-after--li">Therefore, if a middle element is wrongly placed such that a number <code class="markup--code markup--p-code">X</code> was needed in its place where <code class="markup--code markup--p-code">X &lt; Element[Target Index]</code>¬†, then we maintain a counter for that and call it <code class="markup--code markup--p-code">count_low_needed</code>¬†.</p><p name="3940" id="3940" class="graf graf--p graf-after--p">Similarly, if a middle element is wrongly placed such that a number <code class="markup--code markup--p-code">X</code> was needed in its place where <code class="markup--code markup--p-code">X &gt; Element[Target Index]</code>¬†, then we maintain a counter for that and call it <code class="markup--code markup--p-code">count_high_needed</code>¬†.</p><p name="73c2" id="73c2" class="graf graf--p graf-after--p">Also, if we simply run the binary search algorithm over the given array while searching for numbers, there would be some numbers that would be correctly placed. These would be the middle elements that drove the binary search in correct directions corresponding to the given element <code class="markup--code markup--p-code">X</code> (the element to be searched). These numbers cannot be a part of the swapping, because they are rightly positioned with respect to <code class="markup--code markup--p-code">X</code>¬†.</p><p name="5af6" id="5af6" class="graf graf--p graf-after--p">Let‚Äôs look at the pseudo code for this algorithm first and then go through an example.</p><pre name="1d2d" id="1d2d" class="graf graf--pre graf-after--p">function can_preprocess(arr, X)<br>{<br>     low = 0<br>     high= 0<br><br>while X is not found {<br>          mid = (low + high) / 2<br>          if arr[mid] == X {<br>             break           <br>          }<br><br>correctly_placed_low = 0<br>          correctly_placed_high = 0<br>          count_low_needed = 0<br>          count_high_needed = 0<br><br>if `mid` suggests we should go right for X {<br>               if X is actually on the right {<br>                   correctly_placed_low ++<br>               }<br>               else {<br>                   count_low_needed ++<br>               }<br>          } else {<br>               if X is actually on the left {<br>                  correctly_placed_high ++<br>               } <br>               else {<br>                  count_high_needed ++<br>               }<br>          }<br><br>modify low and high according to <br>          where `X` actually is with respect to `mid`<br><br>}<br><br>// Total smaller numbers available for swapping<br>     TSM = sorted_index[X] - correctly_placed_low<br><br>// Total Larger numbers available for swapping<br>     TLM = (N - sorted_index[X]) - correctly_placed_high<br><br>if count_low_needed &gt; TSM or count_high_needed &gt; TLM {<br>          return -1<br>     }<br><br>return max(count_low_needed, count_high_needed)</pre><p name="64a1" id="64a1" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">NOTE: </strong>The problem statement fixes the input array for us and repeatedly passes values to be searched in the input array. So, we can iterate once over the original array to know the actual location of the element to be searched (create a dictionary, essentially).</p><p name="7e98" id="7e98" class="graf graf--p graf-after--p">Also, we need <code class="markup--code markup--p-code">sorted_index[X]</code> to tell us how many values are lesser than or greater than the element <code class="markup--code markup--p-code">X</code> in our array. We can sort the array and create another dictionary storing location of each element in the sorted array.</p><p name="67b6" id="67b6" class="graf graf--p graf-after--p">Let‚Äôs go through the steps of the proposed algorithm while dry running an example.</p><ol class="postList"><li name="c6fe" id="c6fe" class="graf graf--li graf-after--p">Given an unsorted array, you need to search for <code class="markup--code markup--li-code">X = 4</code>¬†.<br>Hence our target index is 7.</li></ol><figure name="1234" id="1234" class="graf graf--figure graf-after--li"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 261px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 37.3%;"></div><img class="graf-image" data-image-id="1*3vnVPsJgCPjLLmWENiB8rQ.png" data-width="1442" data-height="538" src="https://cdn-images-1.medium.com/max/800/1*3vnVPsJgCPjLLmWENiB8rQ.png"></div></figure><p name="3e58" id="3e58" class="graf graf--p graf-after--figure">2. Mid element index &lt; Target Index, so we need to maneuver our search to the right half. But <code class="markup--code markup--p-code">Element[Mid] &gt; Element[Target Index]</code>, hence <code class="markup--code markup--p-code">count_low_needed = 1</code></p><figure name="43bb" id="43bb" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 252px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 35.9%;"></div><img class="graf-image" data-image-id="1*goOz9sCtElJn8_GVf86n-Q.png" data-width="1430" data-height="514" src="https://cdn-images-1.medium.com/max/800/1*goOz9sCtElJn8_GVf86n-Q.png"></div></figure><p name="2c5a" id="2c5a" class="graf graf--p graf-after--figure">3. Mid element index &lt; Target Index, so we still need to maneuver our search to the right half. Once again, <code class="markup--code markup--p-code">Element[Mid] &gt; Element[Target Index]</code>, hence <code class="markup--code markup--p-code">count_low_needed = 2</code></p><figure name="f2be" id="f2be" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 251px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 35.9%;"></div><img class="graf-image" data-image-id="1*RuHR_k66dh-G0KzI-6DRuQ.png" data-width="1444" data-height="518" src="https://cdn-images-1.medium.com/max/800/1*RuHR_k66dh-G0KzI-6DRuQ.png"></div></figure><p name="09d6" id="09d6" class="graf graf--p graf-after--figure">4. The total number of swaps needed for binary search to return the correct index here would be two swaps with elements lower than 4. We have smaller numbers <code class="markup--code markup--p-code">1, 3 or 2</code> for swapping available, so we can successfully do the swapping for this array so that binary search correctly finds out <code class="markup--code markup--p-code">4</code>¬†.</p><p name="c8f4" id="c8f4" class="graf graf--p graf-after--p">Below is the Python code for the given problem. Every step is explained in the comments.</p><figure name="130f" id="130f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/DivyaGodayal/3e01d1befc94da99536093235f4ca971.js"></script></figure><p name="2715" id="2715" class="graf graf--p graf-after--figure">The time complexity of this Twisted Binary Search algorithm is still <code class="markup--code markup--p-code">O(nlogn)</code>¬†.</p><p name="003c" id="003c" class="graf graf--p graf-after--p graf--trailing">I hope you were able to grasp the inner workings of the binary search algorithm and had fun while going through this interesting problem as well. If you found this post useful, spread the love and share as much as possible. üòÉ</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@divyagodayal" class="p-author h-card">Divya Godayal</a> on <a href="https://medium.com/p/49f5ac01e83d"><time class="dt-published" datetime="2018-07-04T00:33:07.157Z">July 4, 2018</time></a>.</p><p><a href="https://medium.com/@divyagodayal/a-twisted-tale-of-binary-search-49f5ac01e83d" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 15, 2018.</p></footer></article></body></html>